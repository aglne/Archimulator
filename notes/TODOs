TODOs:

* polish mesi/moesi protocol implementation and incorporates DIP.
* extends cache access profiling to read/write requests other than ifetches/loads/stores in caches other than level one caches.
* dynamic selection between MLP-aware replacement and LRU replacement
* multithreaded simulation support; especial support for software-based helper threads

* add Apache Commons Math based statistics support to existing code
* add predefined pseudocalls to aid simulation control and notification
* support sampled simulations

* ETA calculation
* perfect branch predictor
* monitoring thread?
* interconnection network
* java command line interface / option parsing

* compile and test all the benchmarks, Olden and CPU2006, original version, MIPS big endian
* compile and test selected benchmarks, Olden and CPU2006, prepush version, MIPS big endian
* examine memory subsystem performance metrics


* fix mapping/brk/mmap/munmap TODOs in memory implementation.
* add CSV export support about key performance metrics between simulations within an experiment
	total instructions (per thread)
	total cycles
	cache misses per level, cache request/miss latencies and mlp based costs
	inter-thread prepushes coverage, accuracy?
* compare mst original and mst prepush

* use HexDemp, EndianUtils from org.apache.commons.io.

* clarify cache miss categorization:

    In the context of lockup-free caches, misses can be classified into three categories (from processor microarchitecture book):
    1. Primary miss: the first miss to a cache block. This miss will initiate a fetch request to the
    higher levels of the memory hierarchy [28].
    2. Secondary miss: subsequent miss to a cache block that is already being fetched due to a pre-
    vious primary miss [28].
    3. Structural-stall miss: a secondary miss that the available hardware resources (i.e., MSHRs)
    cannot handle [10]. Such a miss will cause a stall due to a structural hazard.

* clarify in-cache MSHR implementation:

    in-Cache MSHRs (from processor microarchitecture book):
    An alternative organization that reduces the amount of storage required to hold MSHR informa-
    tion was proposed by Franklin and Sohi [12]. This proposal is based on the observation that the
    cache block waiting to be filled can serve as the MSHR storage. With in-cache MSHRs, the tag
    array needs to hold one more bit per cache block, the transient bit, to indicate that the block is being
    fetched. When in transient mode, the tag array holds the address of the block being fetched, and the
    corresponding data array entry holds MSHR information. The in-cache MSHR can be implicitly
    addressed or explicitly addressed. The benefit of this design is that we can have as many in-flight
    primary misses as blocks in the cache.

* support parallel execution of simulations within an experiment.

* support configuration and simulation of multi-level (level >=3) cache hierarchy.

* support conceptual simulation.


* prepush coverage and accuracy calculation;; to be exposed to statistics report

* cache subblock support.


* implement and examine a few existing and recent cache replacement policies (LRU, NRU, DIP, S/D-RRIP, MLP-Aware, etc.) and mechanisms.

* prepush oriented rereference interval predection: set dueling for prepush identification, ...

* provide hintful items in statistics summary report: cxtx.ipc, cpi, insts; cachex.readHits, readMisses, writeHits, writeMisses, evictions.

* cache pollution measurement, especially of prepushes brought by helper threads.

* examine the reasons about low IPC during simulation: the ooo pipeline's fault or the cache system's fault?

    1. measure l1 cache access statistics, like L2 stastistics in summary report.

    1. measure per set cache access distribution statistics.

    2. measure and reduce the latency of each memory acccesses.

    3. measure and reduce the dispatch stall cycles.

    4. measure and increase the occupancy/read/write ratios of each processor pipeline structures.

    5. reduce the size and associativity of L2 to try to cause evictions?

* add event/action information on memory devices involved to trace file based memory subsystem simulation outputs.

* fix simulation statistics dumping when the simulation is terminated by user.

recent priority:

* introduce subblock granularity into the directory data structure and cache coherence protocol.

* find an independent branch prediction simulator and compare its result with Archimulator's. Refer to:
      The 2nd JILP Championship Branch Prediction Competition (CBP-2)
      (http://cava.cs.utsa.edu/camino/cbp2/)

    * integrate MyBranchPredictor into Archimulator and check its MPKI!!!

* investigate and pick & integrate the select cache replacement algorithms from:
    1st JILP Workshop on Computer Architecture Competitions (JWAC-1): Cache Replacement Championship
    (http://www.jilp.org/jwac-1/)

* investigate and pick & integrate the select data prefetching algorithms from:
    The 1st JILP Data Prefetching Championship (DPC-1)
    (http://www.jilp.org/dpc/)
