#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass IEEEtran
\begin_preamble
% for subfigures/subtables
\ifCLASSOPTIONcompsoc
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\else
\usepackage[caption=false,font=footnotesize]{subfig}
\fi
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tbph
\paperfontsize default
\spacing single
\use_hyperref true
\pdf_title "Parameter Selection Based on Prefetch Breakdown for Helper Threading on CMPs"
\pdf_author "Min Cai, Zhimin Gu"
\pdf_keywords "Chip multiprocessors, helper thread, prefetch breakdown, intra-application cache pollution"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 1
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 2cm
\topmargin 2cm
\rightmargin 2cm
\bottommargin 2cm
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
Parameter Selection Based on Prefetch Breakdown for Helper Threading on
 CMPs
\end_layout

\begin_layout Author
Min
\begin_inset space ~
\end_inset

Cai, Zhimin
\begin_inset space ~
\end_inset

Gu, Xianhe Sun
\begin_inset Foot
status open

\begin_layout Plain Layout
Min Cai, School of Computer Science and Technology, Beijing Institute of
 Technology, Beijing, China, e-mail: 
\begin_inset CommandInset href
LatexCommand href
target "min.cai.china@gmail.com"
type "mailto:"

\end_inset

.
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Zhimin Gu, School of Computer Science and Technology, Beijing Institute
 of Technology, Beijing, China, e-mail: 
\begin_inset CommandInset href
LatexCommand href
target "zmgu@x263.net"
type "mailto:"

\end_inset

.
\end_layout

\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Xianhe Sun, Department of Computer Science, Illinois Institute of Technology,
 Chicago, Illinois, USA, e-mail: 
\begin_inset CommandInset href
LatexCommand href
target "sun@iit.edu"
type "mailto:"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Page headings
\begin_inset Note Note
status open

\begin_layout Plain Layout
Proceedings of XXX
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset

Min Cai 
\begin_inset Flex Lowercase
status open

\begin_layout Plain Layout
et al.
\end_layout

\end_inset

: Shared Cache Partitioning for Helper Threaded Data Prefetching on CMPs
\end_layout

\begin_layout Abstract
For workloads exhibiting irregular memory access patterns, helper threaded
 data prefetching on shared cache chip multiprocessors (CMPs) speculatively
 issue last-level cache (LLC) requests to the predicted memory addresses
 ahead of main thread references.
 Effective helper threaded data prefetching on CMPs demands that the helper
 thread (HT) should issue correct and timely LLC requests just before the
 main thread (MT) references them.
 Unfortunately, this ideal case can not be fulfilled in the practical implementa
tions of helper threaded data prefetching on CMPs: inaccurate and/or untimely
 LLC requests coming from the helper thread could not contribute to the
 main thread performance, but instead stress and pollute LLC if no effective
 LLC replacement and pollution-aware feedback techniques are employed.
\end_layout

\begin_layout Abstract
This paper characterizes the degree by which intra-application LLC interference
 is caused by inter-core data prefetches in the above helper threaded data
 prefetching scheme.
 Since hardware performance counter based measurement on real machines cannot
 provide required fine-grained metrics, using cycle-accurate architectural
 simulation of the memory intensive benchmark mst from Olden, we first adapt
 traditional approaches to characterizing hardware prefetches such as prefetch
 accuracy, coverage and lateness, useful vs.
 useless prefetches to characterize helper threaded data prefetching on
 CMPs.
 Based on the insights from these characterizations, we then propose a fine-grai
ned taxonomy of helper threaded inter-core data prefetches to study the
 intricate interactions between intra-application LLC interference and parameter
s of the helper threaded data prefetching scheme.
 Experimental results show that: (1) there is non-trivial intra-application
 LLC interference caused by inter-core data prefetches in helper-threaded
 data prefetching on CMPs; (2) selecting proper parameters, such as lookahead
 and stride, of the helper threaded data prefetching scheme play a key role
 in maximizing the performance of the scheme.
 Overall, our characterizations are important in interpreting the effectiveness
 of software-initiated helper threaded data prefetching on CMPs by cycle-accurat
e architectural simulation, and highlighting the opportunities and challenges
 of optimizing helper threaded data prefetching on CMPs in a dynamic and
 feedback-directed way.
\end_layout

\begin_layout Keywords
Chip multiprocessors, helper thread, prefetch breakdown, intra-application
 cache pollution
\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
The 
\series bold

\backslash
IEEEPARstart
\series default
 command is needed in the first paragraph fo the document.
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
IEEEPARstart{
\end_layout

\end_inset

 F
\begin_inset ERT
status open

\begin_layout Plain Layout

}{
\end_layout

\end_inset

or
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset

 workloads exhibiting irregular memory access patterns, helper threaded
 data prefetching 
\begin_inset CommandInset citation
LatexCommand cite
key "Kim2004,Byna2008,Lee2009"

\end_inset

 on shared cache chip multiprocessors (CMPs) speculatively issue last-level
 cache (LLC) requests to the predicted memory addresses ahead of main thread
 references.
 Effective helper threaded data prefetching on CMPs demands that the helper
 thread (HT) should issue correct and timely LLC requests just before the
 main thread (MT) references them.
 Unfortunately, this ideal case can not be fulfilled in the practical implementa
tions of helper threaded data prefetching on CMPs: inaccurate and/or untimely
 LLC requests coming from the helper thread could not contribute to the
 main thread performance, but instead stress and pollute LLC if no effective
 LLC replacement and pollution-aware feedback techniques are employed.
\end_layout

\begin_layout Standard
Several metrics have been proposed in the past for evaluating the effectiveness
 of hardware based data prefetching, among which prefetch accuracy and coverage
 are the most intuitive ones 
\begin_inset CommandInset citation
LatexCommand cite
key "Srinivasan2004"

\end_inset

.
 We can easily adapt the definitions of accuracy and coverage for hardware
 based data prefetching to the helper threaded prefetching scheme.
 Helper thread request accuracy is defined as the ratio of the number of
 useful helper thread requests to the number of total helper thread requests.
 And helper thread request coverage is defined as the ratio of the number
 of useful helper thread requests to the number of main thread misses plus
 main thread hits to helper thread requested data.
 Here, a helper thread request is called useful when its requested data
 is referenced by main thread before evicted.
 Furthermore, similar to the approach to hardware prefetching, to measure
 coverage and accuracy, all helper thread requests can be categorized into
 
\begin_inset Quotes eld
\end_inset

useful
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

useless
\begin_inset Quotes erd
\end_inset

 helper thread requests 
\begin_inset CommandInset citation
LatexCommand cite
key "Srinivasan2004"

\end_inset

.
 A 
\begin_inset Quotes eld
\end_inset

useful
\begin_inset Quotes erd
\end_inset

 helper thread request is one whose brought data is hit by a main thread
 request before it is replaced, while a 
\begin_inset Quotes eld
\end_inset

useless
\begin_inset Quotes erd
\end_inset

 helper thread request is one whose brought data is replaced before it is
 hit by a main thread request.
 However the above traditional accuracy and coverage metrics for helper
 thread requests and the classification of 
\begin_inset Quotes eld
\end_inset

useful
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

useless
\begin_inset Quotes erd
\end_inset

 helper thread requests don't care about the LLC pollution and inter-thread
 interference caused by helper thread LLC requests, which are two kinds
 of deficiencies in the helper threaded prefetching scheme.
 
\end_layout

\begin_layout Standard
This paper characterizes the degree by which intra-application LLC interference
 is caused by inter-core data prefetches in the above helper threaded data
 prefetching scheme.
 Since hardware performance counter based measurement on real machines cannot
 provide required finegrained metrics, using cycle-accurate architectural
 simulation of the memory intensive benchmark mst from the Olden pointer
 traversing benchmark suite 
\begin_inset CommandInset citation
LatexCommand cite
key "Rogers1995"

\end_inset

, we first adapt traditional approaches to characterizing hardware prefetches
 such as prefetch accuracy coverage and lateness, useful vs.
 useless prefetches to characterize helper threaded data prefetching on
 CMPs.
 Based on the insights from these characterizations, we then propose a fine-grai
ned taxonomy of helper threaded inter-core data prefetches to study the
 intricate interactions between intra-application LLC interference and parameter
s of the helper threaded data prefetching scheme.
 Experimental results show that: (1) there is non-trivial intra-application
 LLC interference caused by inter-core data prefetches in helper-threaded
 data prefetching on CMPs; (2) selecting proper parameters, such as lookahead
 and stride, of the helper threaded data prefetching scheme play a key role
 in maximizing the performance of the scheme.
 Overall, our characterizations are important in interpreting the effectiveness
 of software-initiated helper threaded data prefetching on CMPs by cycle-accurat
e architectural simulation, and highlighting the opportunities and challenges
 of optimizing helper threaded data prefetching on CMPs in a dynamic and
 feedback-directed way.
 We assume here a two level cache hierarchy where L1 caches are private
 and the L2 cache is shared among all processor cores on a single chip.
 
\end_layout

\begin_layout Standard
The main contributions of this paper can be summarized as answers for the
 following two questions:
\end_layout

\begin_layout Enumerate
What is the relationship between the shared cache behavior and the overall
 performance improvement in helper threaded data prefetching on CMPs;
\end_layout

\begin_layout Enumerate
How can the helper thread LLC requests be classified to reflect the inter-thread
 LLC interference caused by helper thread LLC requests in helper threaded
 data prefetching on CMPs.
\end_layout

\begin_layout Standard
The rest of this paper is structured as follows.
 Section 2 describes the cycle-accurate simulation framework for the target
 CMP architecture and experimental setup.
 Section 3 presents the characterization of LLC interference caused by helper
 threaded data prefetching on CMPs.
 Section 4 discusses the performance results on the detailed experiments.
 Section 5 provides related work.
 Section 6 concludes the paper.
\end_layout

\begin_layout Section
Methodology
\end_layout

\begin_layout Subsection
Target CMP Architecture
\end_layout

\begin_layout Standard
As shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulated-CMP-Architecture"

\end_inset

, the simulated target CMP architecture has two cores where each core is
 a two-way SMT with its own private L1 caches (32KB 4-way data caches and
 32KB 4-way instruction caches).
 Both cores share a 96KB 8-way L2 cache.
 MESI inclusive directory coherence is maintained between L1 caches.
 Both L1 and L2 caches use LRU replacement policy.
 An LRU cache called HTRVC is attached to the L2 cache to implement the
 taxonomy of helper thread LLC requests, as will be explained in the next
 section.
 Detailed microarchitecture parameters are listed in Tab.
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:Baseline-Hardware-Configurations"

\end_inset

.
\end_layout

\begin_layout Subsection
Simulation Framework
\end_layout

\begin_layout Standard
We use the open source Archimulator
\begin_inset Foot
status open

\begin_layout Plain Layout
See 
\begin_inset CommandInset href
LatexCommand href
target "http://github.com/mcai/archimulator/"

\end_inset

 for details.
\end_layout

\end_inset

 CMP architectural simulation environment in our experiments mentioned in
 this work.
 Archimulator is an object-oriented execution-driven application-only architectu
ral simulator written completely in Java and running on 32 and 64 bit Linux
 based operating systems.
 It provides three modes of functional simulation, cycle-accurate simulation
 and two-phase fast forward and measurement simulation of MIPS II executables
 on CMP architectures consisting of out-of-order super-scalar cores and
 configurable memory hierarchies with directory-based MESI coherence.
 It supports simulating Pthreads based multithreaded workloads.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Archimulator/doc/res/cacheconfig.pdf
	scale 72
	BoundingBox 26bp 480bp 575bp 750bp
	clip

\end_inset


\begin_inset VSpace defskip
\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Target CMP Architecture
\begin_inset CommandInset label
LatexCommand label
name "fig:Simulated-CMP-Architecture"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Static Software Context to Hardware Thread Mappings
\end_layout

\begin_layout Standard
In a typical Pthreads based helper thread program, there are three threads
 when running: main thread, helper thread and the Pthreads manager thread.
 The Pthreads manager thread takes the role of spawning, suspending and
 resuming helper thread by passing signals to helper thread.
 Consider a simulated target CMP machine which has two cores where each
 core supports two hardware threads.
 In our application-only simulation using Archimulator, without the OS intervent
ion, one hardware thread can only run at least one software context (or
 simply called thread).
 Therefore, the typical software context to hardware thread mappings can
 be: C0T0 
\begin_inset Formula $\rightarrow$
\end_inset

 main thread, C0T1 
\begin_inset Formula $\rightarrow$
\end_inset

 Pthreads manager thread, C1T0 
\begin_inset Formula $\rightarrow$
\end_inset

 helper thread (C = core, T = thread), as shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulated-CMP-Architecture"

\end_inset

.
 We use this context mapping in the following discussions.
 
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
Baseline Hardware Configurations
\begin_inset CommandInset label
LatexCommand label
name "tab:Baseline-Hardware-Configurations"

\end_inset


\end_layout

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="10" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell multirow="3" alignment="left" valignment="middle" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pipeline
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4-wide superscalar out-of-order core; 2 cores, 2 threads per core
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Physical register file capacity: 128
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Decode buffer capacity: 96
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reorder buffer capacity: 96
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Load store queue capacity: 48
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Branch Predictors
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Perfect branch predictor
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Functional Units
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="12" columns="4">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FU Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Count
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Operation Lat.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Issue Lat.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer ALU
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Intger Multiply
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer Division
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Floating Point Add
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Floating Point Compare
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Floating Point Convert
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Floating Point Multiply
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Floating Point Division
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Floating Point Square Root
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
80
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
40
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Read Port
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Write Port
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Cache Geometries
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="5">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Size
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Associativity
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Line Size
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hit Lat.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I Cache
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32KB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D Cache
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
32KB
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L2 Cache
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
96KB
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64B
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Interconnect
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Switch based P2P topology, 32B link width
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Main Memory
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4GB, 200-cycle fixed latency
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Benchmarks and Input Sets
\end_layout

\begin_layout Standard
We perform our evaluation using the original version and manually coded
 helper thread version of mst in the Olden pointer traversal benchmark suite.
 All applications are cross-compiled using gcc flag “-O3” and run until
 completion using cycle-accurate simulation.
 Input set for mst is 
\begin_inset Quotes eld
\end_inset

2048 1
\begin_inset Quotes erd
\end_inset

.
 Default helper threaded prefetching lookahead and stride are 20 and 10,
 respectively.
\end_layout

\begin_layout Section
Characterizing LLC Interference Caused by Helper Threaded Prefetching
\end_layout

\begin_layout Subsection
The Scheme of Helper Threaded Data Prefetching on Shared-Cache CMPs
\end_layout

\begin_layout Standard
As illustrated in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Helper-Threaded-Inter-Core-Data-Prefetching"

\end_inset

, the work flow of helper threaded data prefetching on shared-cache CMPs
 we implement here can be described as follows.
 
\end_layout

\begin_layout Enumerate
The helper thread is spawned in the entry point 
\shape italic
main()
\shape default
 of the program; 
\end_layout

\begin_layout Enumerate
The helper thread remains dormant until some caller of the target hotspot
 function has been invoked and code placed in the caller wakes up the helper
 thread to let it start the 
\shape italic
prelude
\shape default
 where the code in the helper thread skips some iterations of pointer traversals
 (i.e., there is no prefetch issued) to compensate the long time used for
 data prefetching in the helper thread as compared to the short time used
 in computation work in the main thread; 
\end_layout

\begin_layout Enumerate
The helper thread enters a 
\shape italic
stable state
\shape default
 of issuing LLC prefetch requests in loop iterations of pointer traversals
 ahead of the main thread until the execution of the program has passed
 some point(s) in the target hotspot function; 
\end_layout

\begin_layout Enumerate
The code in helper thread is synchronizing pointers with the main thread
 and begin the next turn of servicing hotspots; 
\end_layout

\begin_layout Enumerate
After all the prefetching work is done, the helper thread is destroyed in
 main().
 
\end_layout

\begin_layout Standard
Two parameters in the helper threaded prefetching scheme control its aggressiven
ess: (1) the number of loop iterations of pointer traversals that the helper
 thread code skip after synchronizing with the main thread in the prelude
 is called 
\shape italic
lookahead
\shape default
; (2) the number of loop iterations of pointer traversals in which helper
 thread code issue LLC prefetch requests in the stable state is called 
\shape italic
stride
\shape default
.
 
\end_layout

\begin_layout Standard
In the traditional helper threaded prefetching configuration, the values
 of lookahead and stride are selected empirically and hard coded, which
 is unable to accommodate the unpredictable nature of L2 cache runtime behavior
 in the presence of helper thread requests.
 Based on our following characterization of helper thread L2 requests, a
 dynamic feedback directed mechanism can be built in which the processor
 changes the value of lookahead and stride using some temporary registers
 to adjust the aggressiveness of the helper threaded prefetching scheme.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename /home/itecgo/Archimulator/doc/ht_scheme.pdf
	scale 45
	BoundingBox 30bp 38bp 810bp 538bp
	clip

\end_inset


\begin_inset VSpace defskip
\end_inset


\begin_inset Caption

\begin_layout Plain Layout
The Scheme of Helper Threaded Data Prefetching on CMPs
\begin_inset CommandInset label
LatexCommand label
name "fig:Helper-Threaded-Inter-Core-Data-Prefetching"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Adapting Traditional Hardware Prefetching Metrics to Helper Threaded Prefetching
\end_layout

\begin_layout Standard
Traditionally, prefetch accuracy, coverage and lateness are used to evaluate
 the effectiveness of hardware prefetchers 
\begin_inset CommandInset citation
LatexCommand cite
key "Srinivasan2004"

\end_inset

.
 In this section, we adapt the metrics to the helper threaded prefetching
 scheme and describe what the metrics mean under the helper threaded prefetching
 scheme.
\end_layout

\begin_layout Paragraph
Useful vs.
 Useless Helper Thread LLC Requests
\end_layout

\begin_layout Standard
Helper thread requests can be categorized into useful and useless helper
 thread requests.
 A 
\shape italic
useful helper thread request
\shape default
 is one whose brought data is hit by a main thread request before it is
 replaced, while a 
\shape italic
useless helper thread request
\shape default
 is one whose brought data is replaced before it is hit by a main thread
 request.
 
\end_layout

\begin_layout Paragraph
Helper Thread LLC Request Accuracy
\end_layout

\begin_layout Standard

\shape italic
Helper thread LLC request accuracy
\shape default
 is a measure of how accurately the helper threaded prefetching scheme can
 predict and issue prefetch requests for the memory addresses that will
 be accessed by the main thread.
 It is defined as below
\end_layout

\begin_layout Standard

\size scriptsize
\begin_inset Formula 
\begin{equation}
Accuracy=\frac{\#\: Useful\: Helper\: Thread\: LLC\: Requests}{\#\: Helper\: Thread\: LLC\: Requests}
\end{equation}

\end_inset


\size default
where # Useful helper thread LLC Requests is the number of LLC lines brought
 by helper thread requests that are later on hit by helper thread requests.
 For benchmarks with high helper thread LLC request accuracy, performance
 increases as the aggressiveness of the helper threaded prefetching scheme
 is increased.
\end_layout

\begin_layout Paragraph
Helper Thread LLC Request Coverage
\end_layout

\begin_layout Standard

\shape italic
Helper thread LLC request coverage
\shape default
 is a measure of the fraction of all main thread LLC misses in the baseline
 version where helper thread is switched off that can be converted into
 hits by issuing helper thread LLC misses ahead in the helper thread version.
 It is defined as below
\end_layout

\begin_layout Standard

\size scriptsize
\begin_inset Formula 
\begin{equation}
Coverage=\frac{\#\: Useful\: Helper\: Thread\: LLC\: Requests}{\#\: Main\: Thread\: LLC\: Requests\: w/o\: Helper\: Thread}
\end{equation}

\end_inset


\end_layout

\begin_layout Paragraph
Helper Thread LLC Request Lateness
\end_layout

\begin_layout Standard

\shape italic
Helper thread LLC request lateness
\shape default
 is a measure of how timely the LLC requests generated in the helper thread
 are with respect to the LLC requests generated in the main thread that
 need the data brought by the helper thread.
 A helper thread LLC request is said to be late if its requested data has
 not yet returned from the main memory by the time a main thread LLC request
 references the data.
 Therefore, even though the helper thread LLC request is accurate, it can
 only partially hide the latency incurred by an LLC miss in the main thread.
 Helper thread
\shape italic
 LLC request lateness
\shape default
 can be defined as below
\end_layout

\begin_layout Standard

\size footnotesize
\begin_inset Formula 
\begin{equation}
Lateness=\frac{\#\: Late\: Helper\: Thread\: LLC\: Requests}{\#\: Useful\: Helper\: Thread\: LLC\: Requests}
\end{equation}

\end_inset


\end_layout

\begin_layout Subsection
Characterizing Intra-application LLC interference
\end_layout

\begin_layout Subsubsection
Intra-Application Reuse Distances in Helper Threaded Data Prefetching on
 CMPs
\end_layout

\begin_layout Standard
The notion of reuse distance can shed light on how a pollution-aware taxonomy
 of helper thread LLC requests can be constructed.
 The traditional intra-thread reuse distance of a reference to data element
 x is defined as the number of unique memory references between two consecutive
 accesses of x in the same thread (or ∞ if the element has not been referenced
 thereafter).
 In a k-way set-associative cache a cache miss with reuse distance rd can
 be classified by the value of reuse distance as below
\end_layout

\begin_layout Enumerate
rd < k indicates it is a 
\shape italic
conflict miss
\shape default
;
\end_layout

\begin_layout Enumerate
k<= rd < 
\begin_inset Formula $\infty$
\end_inset

 indicates it is a 
\shape italic
capacity miss
\shape default
;
\end_layout

\begin_layout Enumerate
rd = 
\begin_inset Formula $\infty$
\end_inset

 indicates it is a 
\shape italic
cold miss.
\end_layout

\begin_layout Standard
To accommodate the case where one thread Tb accesses data element x that
 has been previously brought into the cache by another thread Ta, we introduce
 the notion of Ta-Tb inter-thread reuse distance, as compared to the traditional
 intra-thread reuse distance applied to either Ta or Tb.
\end_layout

\begin_layout Standard
To show why the notion of inter-thread reuse distance is important in the
 helper threaded prefetching scheme as compared to the traditional notion
 of intra-thread reuse distance, we can consider the mst benchmark in the
 Olden suite.
 Its pointer traversing code structure inherently exhibits irregular memory
 access pattern in its original, single threaded version, which renders
 the common LRU replacement policy inefficient to reduce LLC misses.
 Here we use 
\begin_inset Formula $RD_{MT}$
\end_inset

 to refer to the 
\shape italic
intra-thread reuse distance
\shape default
 in the main thread, and 
\begin_inset Formula $ITRD_{HT-MT}$
\end_inset

 to refer to the 
\shape italic
inter-thread reuse distance
\shape default
 between helper thread and main thread where a data element is first brought
 to LLC by helper thread, and later on used by main thread.
 Therefore, the values of 
\begin_inset Formula $RD_{MT}$
\end_inset

 in most main thread LLC requests is high which reflects the irregular memory
 access pattern in mst.
 The values of 
\begin_inset Formula $ITRD_{HT-MT}$
\end_inset

 in helper thread LLC requests should be very small when the helper threaded
 prefetching scheme is efficient to reduce LLC misses in main thread where
 for most helper thread LLC miss, an immediate follow-up main thread LLC
 request will access the data brought by the previous LLC request and hit
 in the LLC.
 Otherwise, large values of 
\begin_inset Formula $ITRD_{HT-MT}$
\end_inset

 indicate the inefficiency of the helper threaded prefetching scheme where
 most data brought by helper thread is replaced before used by main thread.
\end_layout

\begin_layout Standard
Helper thread induced cache pollution with respect to main thread performance
 only happens when helper thread LLC requests evict the data that are previously
 brought by main thread and immediately referenced again by main thread
 LLC requests, but rarely happens when helper thread LLC requests evict
 any data that was previously brought by main thread but will not be used
 by main thread in the near future, which is typically the case in mst which
 exhibits a thrashing memory access pattern and thus most of the data requested
 from its delinquent PCs have instant main thread intra-thread reuse distances
 but small helper thread-main thread inter-thread reuse distances, which
 renders traditional intra-thread reuse distance prediction based LLC replacemen
t useless for mst with helper thread.
 Fortunately, as we will see, HT-MT inter-thread reuse distance prediction
 based LLC replacement can be useful for mst with helper thread.
\end_layout

\begin_layout Subsubsection
A Simple Taxonomy of Helper Thread LLC Requests Based on Intra-Application
 Reuse Distances
\end_layout

\begin_layout Standard
Based on the notions of HT-MT inter-thread reuse distance (
\begin_inset Formula $ITRD_{HT-MT}$
\end_inset

) and main thread intra-thread reuse distance (
\begin_inset Formula $RD_{MT}$
\end_inset

), we can construct a pollution aware taxonomy of helper thread LLC requests
 where helper thread LLC requests are classified into three types: good,
 bad and ugly.
 Let's assume when a helper thread LLC request referencing data H evicts
 an LLC line containing the victim data V which is brought by main thread,
 and afterwards the LLC line containing H is evicted by a main thread LLC
 request with data M.
 Therefore, there are two LLC replacement involved: first H evicts V and
 then M evicts H.
 We use 
\begin_inset Formula $RD_{MT}(v)$
\end_inset

, 
\begin_inset Formula $ITRD_{HT-MT}(h)$
\end_inset

 and 
\begin_inset Formula $RD_{MT}(m)$
\end_inset

 to denote the number of distinct data elements that have been referenced
 between the time when H evicts V and the time V, H and M is accessed again,
 respectively.
 The greater the reuse distance of the data, the farther the data will be
 referenced again in time.
 An LLC replacement is considered as optimal if the replacement makes the
 data with small reuse distance evicts the data with larger reuse distance,
 otherwise the replacement is considered as non-optimal.
 We have
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $ITRD_{HT-MT}(H)$
\end_inset

 < 
\begin_inset Formula $RD_{MT}(V)$
\end_inset

 < 
\begin_inset Formula $RD_{MT}(M)$
\end_inset

, then the helper thread LLC request is considered as 
\shape italic
good 
\shape default
because it evicts the data that has larger reuse distance than its own.
 Its data is hit by the main thread before evicted.
 It has positive impact on the main thread performance since it reduce one
 main thread miss;
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $RD_{MT}(V)$
\end_inset

 < 
\begin_inset Formula $ITRD_{HT-MT}(H)$
\end_inset

 < 
\begin_inset Formula $RD_{MT}(M)$
\end_inset

, then the helper thread LLC request is considered as
\shape italic
 bad
\shape default
 because it evicts the data that has smaller reuse distance than its own.
 It displaces an LLC line that will later be needed by the main thread.
 It is harmful for main thread performance which should be prevented as
 much as possible; 
\end_layout

\begin_layout Enumerate
if 
\begin_inset Formula $RD_{MT}(M)$
\end_inset

 < 
\begin_inset Formula $RD_{MT}(V)$
\end_inset

 and 
\begin_inset Formula $ITRD_{HT-MT}(H)$
\end_inset

, then the helper thread LLC request is considered 
\shape italic
ugly
\shape default
 because both its data and its victim data have larger reuse distances than
 the data H.
 It has little performance impact on main thread performance because the
 requested data is not referenced by main thread before evicted and it does
 not evict any data that will be used by main thread.
\end_layout

\begin_layout Standard
As depicted in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:taxonomy_ht_llc_requests"

\end_inset

, We can see that, good and bad helper thread LLC requests are caused by
 the optimal and non-optimal LLC replacement in the presence of helper threaded
 data prefetching on CMPs, respectively.
 We can conclude that
\end_layout

\begin_layout Enumerate
Low 
\begin_inset Formula $ITRD_{HT-MT}$
\end_inset

 is an indicator of good performance of the helper threaded prefetching
 scheme;
\end_layout

\begin_layout Enumerate
Medium 
\begin_inset Formula $ITRD_{HT-MT}$
\end_inset

 signals those potentially late helper thread prefetches that, depend on
 the LLC replacement policy, may be useful, partially useful or totally
 useless for main thread performance;
\end_layout

\begin_layout Enumerate
High 
\begin_inset Formula $ITRD_{HT-MT}$
\end_inset

 implies helper thread and main thread is not synchronized well or the amount
 of (computational and memory access) work is not distributed and balanced
 well between the main thread and helper thread.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Graphics
	filename prefetch_timeline.pdf
	scale 45
	BoundingBox 30bp 25bp 810bp 530bp
	clip

\end_inset


\begin_inset VSpace defskip
\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Taxonomy of Helper Thread LLC Requests
\begin_inset CommandInset label
LatexCommand label
name "fig:taxonomy_ht_llc_requests"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Add Lateness to the Taxonomy of Helper Thread LLC Requests
\end_layout

\begin_layout Standard
As noted in the previous section, good helper thread LLC requests can be
 further divided into timely requests and late requests.
 A helper thread request is called 
\shape italic
late helper thread request 
\shape default
if its requested data has not yet returned from the main memory by the time
 a main thread LLC request references the data.
 Late helper thread requests only partially hide the LLC miss latency in
 main thread requests, but they are good indicators for potential performance
 improvement of the helper threaded prefetching scheme because late helper
 thread requests may be converted to timely helper thread requests by adjusting
 the aggressiveness parameters of the helper threaded prefetching scheme,
 i.e., lookahead and stride.
 
\end_layout

\begin_layout Standard
As we can observe that, if the helper thread request is too late, then when
 the request arrives at LLC, it find its referenced data is already present
 in either LLC or LLC MSHRs.
 Therefore, we can add 
\shape italic
redundant_mshr helper thread request 
\shape default
and
\shape italic
 redundant_cache helper thread request 
\shape default
to the taxonomy, as shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:taxonomy_ht_llc_requests"

\end_inset

.
\end_layout

\begin_layout Subsection
Mechanisms and Algorithms for Implementing the Taxonomy
\end_layout

\begin_layout Subsubsection
LLC request and replacement event tracking
\end_layout

\begin_layout Standard
To monitor the request and replacement activities in LLC, we need to consider
 the event when the LLC receives a request coming from the upper level cache,
 whether it is a hit or a miss.
 The event has a few important properties to be used in the experiment,
 e.g., the address of the requested LLC line, the requester memory hierarchy
 access, line found in the LLC, a boolean value indicating whether the request
 hits in the LLC, and a boolean value indicating whether the request needs
 to evict some LLC line.
 This event is similar to one used in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mehta2004"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Helper Thread LLC request state tracking
\end_layout

\begin_layout Standard
In order to track the helper thread request states in the LLC, we need to
 add one field to each LLC line to indicate whether the line is brought
 by the main thread or the helper thread or otherwise invalid, as depicted
 in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulated-CMP-Architecture"

\end_inset

.
 
\end_layout

\begin_layout Subsubsection
Helper Thread LLC request victim state tracking
\end_layout

\begin_layout Standard
In order to track victims replaced by helper thread requests, we need to
 add an LRU cache named 
\shape italic
Helper Thread Request Victim Cache (HTRVC)
\shape default
 to maintain the LLC lines that are evicted by helper thread requests.
 As shown in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Simulated-CMP-Architecture"

\end_inset

, the HTRVC has the same structure of the LLC, but there is no direct mapping
 between LLC lines and HTRVC lines.
 One field called HTRequestTag is added to HTRVC to enable reverse lookup
 in HTRVC by the helper thread request tag in LLC.
 HTRVC has the sole purpose of profiling, so it has no impact on performance.
\end_layout

\begin_layout Subsubsection
Detecting Late Helper Thread LLC Requests
\end_layout

\begin_layout Standard
Lastly, in order to measure late helper thread requests, we need to identify
 the event when a main thread request hits to an LLC line which is being
 brought by an in-flight helper thread request coming from the upper level
 cache.
 This can be accomplished by monitoring the LLC Miss Status Holding Register
 (MSHR).
 MSHR is a hardware structure that keeps track of all in-flight memory requests.
 An helper thread LLC request is late if a main thread LLC request for the
 same address is generated while the helper thread LLC request is in the
 LLC MSHR waiting for main memory.
\end_layout

\begin_layout Subsubsection
Tracking Helper Thread LLC Requests and Victims
\end_layout

\begin_layout Standard
There are two following invariants that should be maintained between LLC
 and HTRVC per set
\end_layout

\begin_layout Enumerate
Number of helper thread Lines in the LLC Set = Number of Victim Entries
 in the HTRVC Set;
\end_layout

\begin_layout Enumerate
Number of Victim Entries in HTRVC Set + Number of Valid main thread LLC
 Lines in Set ≤ LLC Set Associativity.
\end_layout

\begin_deeper
\begin_layout Standard
Helper thread lines refer to the LLC lines that are brought by helper thread
 requests.
 From the above two invariants, we can easily conclude that: Number of helper
 thread Lines in the LLC Set+ Number of Valid main thread LLC Lines in Set
 ≤ LLC Associativity.
 Actions should be taken in LLC and HTRVC when filling an LLC line and servicing
 an incoming LLC request either from the main thread or the helper thread.
\end_layout

\end_deeper
\begin_layout Paragraph
Actions taken on Inserting an LLC Line
\end_layout

\begin_layout Standard
When filling an LLC line, we should consider four cases
\end_layout

\begin_layout Enumerate
An helper thread request evicts an INVALID line.
 In this case, no eviction is needed;
\end_layout

\begin_layout Enumerate
An helper thread request evicts an LLC line which is previously brought
 by a main thread request.
 In this case, eviction is needed to make room for the incoming helper thread
 request;
\end_layout

\begin_layout Enumerate
An helper thread request evicts an LLC line which is previously brought
 by a helper thread request.
 In this case, eviction is needed to make room for the incoming helper thread
 request;
\end_layout

\begin_layout Enumerate
An main thread request evicts an LLC line which is previously brought by
 a helper thread request.
 In this case, eviction is needed to make room for the incoming main thread
 request.
\end_layout

\begin_layout Standard
Specific actions taken on the above four cases are listed in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:inserting-an-LLC-line"

\end_inset

, where hitInLLC indicates whether the request hits in LLC or not; requesterIsHe
lperThread indicates whether the request comes from helper thread or not;
 hasEviction indicates whether the request needs to evict some data; lineFoundIs
HelperThread indicates whether the LLC line found is brought by helper thread
 or not.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small},breaklines=true,frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

//Case 1
\end_layout

\begin_layout Plain Layout

if(requesterIsHelperThread && !hitInLLC && !hasEviction) {
\end_layout

\begin_layout Plain Layout

  llc.setHelperThread(set, llcLine.way);
\end_layout

\begin_layout Plain Layout

  htrvc.insertNullEntry(set);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//Case 2
\end_layout

\begin_layout Plain Layout

else if(requesterIsHelperThread && !hitInLLC && hasEviction && !lineFoundIsHelpe
rThread) {
\end_layout

\begin_layout Plain Layout

  llc.setHelperThread(set, llcLine.way);
\end_layout

\begin_layout Plain Layout

  htrvc.insertDataEntry(set, llcLine.tag);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//Case 3
\end_layout

\begin_layout Plain Layout

else if(requesterIsHelperThread && !hitInLLC && hasEviction && lineFoundIsHelper
Thread) {
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//Case 4
\end_layout

\begin_layout Plain Layout

else if(!requesterIsHelperThread && !hitInLLC && hasEviction && lineFoundIsHelpe
rThread) {
\end_layout

\begin_layout Plain Layout

  llc.setMainThread(set, llcLine.way);
\end_layout

\begin_layout Plain Layout

  htrvc.invalidateVictimLine(set, wayOfVictimLine);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Actions Taken When Inserting an LLC Line
\begin_inset CommandInset label
LatexCommand label
name "fig:inserting-an-LLC-line"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Actions taken on Servicing an Incoming LLC Request
\end_layout

\begin_layout Standard
When servicing an incoming LLC request, either hit or miss, we should consider
 four cases:
\end_layout

\begin_layout Enumerate
LLC miss and victim hit, which indicates a bad helper thread request.
 This happens when helper thread request evicts useful data;
\end_layout

\begin_layout Enumerate
Helper thread LLC hit, which indicates a good helper thread request.
 This happens when helper thread requested data is hit by main thread request
 before evicted data;
\end_layout

\begin_layout Enumerate
Helper thread LLC hit and victim hit.
 This happens when useful data is evicted and brought back in by helper
 thread request;
\end_layout

\begin_layout Enumerate
Main thread LLC hit and victim hit.
 This happens when useful data is evicted and brought back in by helper
 thread request and hit to by main thread request;
\end_layout

\begin_layout Standard
Specific actions taken on the above four cases are listed in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Servicing-an-LLC-Request"

\end_inset

, where mainThreadHit indicates whether the request comes from main thread
 and hits in the LLC; helperThreadHit indicates whether the request comes
 from helper thread and hits in the LLC; and victimHit indicates whether
 the request comes from main thread and hits in the HTRVC.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset listings
lstparams "basicstyle={\small},breaklines=true,frame=single,language=Java"
inline false
status open

\begin_layout Plain Layout

//Case 1
\end_layout

\begin_layout Plain Layout

if(!mainThreadHit && !helperThreadHit && victmHit) {
\end_layout

\begin_layout Plain Layout

  badHelperThreadRequests++;
\end_layout

\begin_layout Plain Layout

  htrvc.clearVictimLine(set, victmLine.way);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//Case 2
\end_layout

\begin_layout Plain Layout

else if(!mainThreadHit && helperThreadHit && !victmHit) {
\end_layout

\begin_layout Plain Layout

  llc.setMainThread(set, llcLine.way);
\end_layout

\begin_layout Plain Layout

  (timely or late)HelperThreadRequests++;
\end_layout

\begin_layout Plain Layout

  htrvc.invalidateVictimLine(set, wayOfVictimLine);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//Case 3
\end_layout

\begin_layout Plain Layout

else if(!mainThreadHit && helperThreadHit && victmHit) {
\end_layout

\begin_layout Plain Layout

  llc.setMainThread(set, llcLine.way);
\end_layout

\begin_layout Plain Layout

  htrvc.invalidateVictimLine(set, wayOfVictimLine);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout

//Case 4
\end_layout

\begin_layout Plain Layout

else if(mainThreadHit && !helperThreadHit && victmHit) {
\end_layout

\begin_layout Plain Layout

  htrvc.clearVictimLine(set, victmLine.way);
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace defskip
\end_inset


\begin_inset Caption

\begin_layout Plain Layout
Actions Taken When Servicing an LLC Request
\begin_inset CommandInset label
LatexCommand label
name "fig:Servicing-an-LLC-Request"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Performance Results
\end_layout

\begin_layout Subsection
Basic Results
\end_layout

\begin_layout Standard
Tab.
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mst-Baseline-Performance"

\end_inset

 shows the overall performance of mst benchmark baseline version, in which
 L2 size is varied from 96 KB to 2 MB and L2 associativity is varied from
 2 to 16, respectively.
 In Tab.
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mst-Baseline-Performance"

\end_inset

 (a), we can see that when the L2 size is greater than 128 KB, there is
 no difference in execution time, implying the working set of mst 
\begin_inset Quotes eld
\end_inset

2048 1
\begin_inset Quotes erd
\end_inset

 with helper threaded prefetching switched off is near 128 KB.
 L2 sizes larger than 128 KB contribute little to the overall performance.
 Tab.
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mst-Baseline-Performance"

\end_inset

 (b) shows that the execution time is insensitive to the L2 associativity
 when the latter is greater than 4.
 Trivial speedups are observed in these basic experiments of mst benchmark
 baseline versions, which is however in contrast to the results observed
 in mst helper threaded prefetching versions as we will discuss shortly
 after.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
mst Baseline Performance
\begin_inset CommandInset label
LatexCommand label
name "tab:mst-Baseline-Performance"

\end_inset


\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_tables/mst_2048_baseline_l2_96KB_to_2MB_summary.pdf
	scale 62
	BoundingBox 30bp 1035bp 810bp 1165bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(a) Impact of L2 Size
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_tables/mst_2048_baseline_l2_2way_to_32way_summary.pdf
	scale 62
	BoundingBox 30bp 1050bp 810bp 1165bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(b) Impact of L2 Associativity
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
\begin_inset Float table
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Caption

\begin_layout Plain Layout
mst Helper Thread Performance
\begin_inset CommandInset label
LatexCommand label
name "tab:mst-Helper-Threaded-Prefetching-Performance"

\end_inset


\end_layout

\end_inset


\begin_inset Tabular
<lyxtabular version="3" rows="4" columns="1">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_tables/mst_2048_ht_20_10_l2_96KB_to_2MB_summary.pdf
	scale 62
	BoundingBox 30bp 935bp 810bp 1165bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(a) Impact of L2 Size
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_tables/mst_2048_ht_20_10_l2_2way_to_32way_summary.pdf
	scale 62
	BoundingBox 30bp 965bp 810bp 1165bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(b) Impact of L2 Associativity
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Tab.
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mst-Helper-Threaded-Prefetching-Performance"

\end_inset

 shows the overall performance of mst benchmark helper threaded prefetching
 version, in which L2 size is varied from 96 KB to 2 MB and L2 associativity
 is varied from 2 to 16, respectively.
 In Tab.
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mst-Helper-Threaded-Prefetching-Performance"

\end_inset

 (a), we can see that when the L2 size is greater than 512 KB, there is
 no difference in execution time, implying the working set of mst 
\begin_inset Quotes eld
\end_inset

2048 1
\begin_inset Quotes erd
\end_inset

 with helper threaded prefetching switched on is near 512 KB.
 L2 sizes larger than 512 KB contribute little to the overall performance.
 Tab.
\begin_inset CommandInset ref
LatexCommand ref
reference "tab:mst-Helper-Threaded-Prefetching-Performance"

\end_inset

 (b) shows that the execution time is reduced slightly as the L2 associativity
 is increased from 2 to 32.
 The presence of helper threaded prefetching increases the working set of
 mst 
\begin_inset Quotes eld
\end_inset

2048 1
\begin_inset Quotes erd
\end_inset

 from 128 KB in the baseline version to 512 KB, and also incur much more
 conflict misses.
 The number of bad prefetches is reduced from 3M to zero when L2 size is
 increased from 96 KB to 512 KB (the working set limit).
 The increase of L2 associativity can also reduce the number of bad prefetches
 as well.
 We can see that bad prefetches are in the forms of capacity and conflict
 misses in this scenario.
 About 1%-3% reductions of execution time are achieved in these basic experiment
s of mst benchmark helper threaded prefetching versions.
 A maximum 22% reduction of execution is achieved between baseline and helper
 thread versions of mst in these basic experiments, which shows our implemented
 helper threaded prefetching scheme is non-trivially effective for the mst
 benchmark.
\end_layout

\begin_layout Subsection
Impact of L2 Size
\end_layout

\begin_layout Standard
Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Impact-of-L2-Size-mst-ht"

\end_inset

 shows the normalized execution times in cycles and helper threaded L2 request
 breakdown for the mst helper threaded prefetching version when the L2 size
 is increased from 96 KB to 2 MB.
 For clarity, execution times are normalized to the first case in the figure
 where L2 size is 96 KB, The 128 KB working set limit of mst 
\begin_inset Quotes eld
\end_inset

2048
\begin_inset Quotes erd
\end_inset

 helper threaded prefetching version is reiterated.
 A few ugly helper thread L2 requests are observed when the L2 size is as
 small as 96 KB, which results from where the helper thread first prefetch
 some potentially useful data into the L2 cache, but due to the limited
 capacity of the L2 cache, these data are evicted too early from the L2
 cache before the main thread uses them.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_20_10_l2_96KB_to_2MB_totalCycles_normalized.pdf
	scale 58
	BoundingBox 0bp 0bp 347bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_20_10_l2_96KB_to_2MB_helperThreadL2CacheRequestBreakdowns.pdf
	scale 58
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(a) Normalized Total Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(b) Helper Thread L2 Request Breakdown
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Impact of L2 Size on mst Helper Thread Performance (lookahead=20, stride=10)
\begin_inset CommandInset label
LatexCommand label
name "fig:Impact-of-L2-Size-mst-ht"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Impact of L2 Associativity
\end_layout

\begin_layout Standard
Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Impact-of-L2-Assoc-mst-ht"

\end_inset

 shows the normalized execution times in cycles and helper threaded L2 request
 breakdown for the mst helper threaded prefetching version when the L2 associati
vity is varied from 2 to 16.
 For clarity, execution times are normalized to the first case in the figure
 where L2 associativity is 2.
 A few ugly helper thread L2 requests are observed when the L2 associativity
 is smaller than 16, which results from where the helper thread first prefetch
 some potentially useful data into the L2 cache, but due to the limited
 associativity of the L2 cache, these data are evicted too early from the
 L2 cache before the main thread uses them.
 
\end_layout

\begin_layout Standard
One important point to notice is that, a few redundant hit-to-cache helper
 thread L2 requests are constantly observed among the experiments shown
 in Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Impact-of-L2-Size-mst-ht"

\end_inset

 and Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Impact-of-L2-Assoc-mst-ht"

\end_inset

, which implies the helper thread is sometimes initiated too late to prefetch
 the data, as the data is already put in the L2 cache by the main thread,
 thus leading to the waste of cache resource and on-chip interconnect bandwidth.
 This deficiency can only be improved by fine-tuning the helper threaded
 prefetching program code, which is out of the scope of this work.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_20_10_l2_2way_to_32way_totalCycles_normalized.pdf
	scale 58
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_20_10_l2_2way_to_32way_helperThreadL2CacheRequestBreakdowns.pdf
	scale 58
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(a) Normalized Total Cycles
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(b) Helper Thread L2 Request Breakdown
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Impact of L2 Associativity on mst Helper Thread Performance (lookahead=20,
 stride=10)
\begin_inset CommandInset label
LatexCommand label
name "fig:Impact-of-L2-Assoc-mst-ht"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Impact of Prefetching Lookahead
\end_layout

\begin_layout Standard
Below we see how the two parameters lookahead and stride of the helper threaded
 prefetching scheme affect the helper thread L2 request breakdown and thus
 the overall performance.
 Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Impact-of-Lookahead-mst-ht"

\end_inset

 shows the normalized execution times in cycles and helper threaded L2 request
 breakdown for the mst helper threaded prefetching version when the lookahead
 is varied from 10 to 480.
 For clarity, execution times are normalized to the first case in the figure
 where the lookahead is 10.
 We can see that when the stride is less than 40, the execution time increases
 monotonically as the lookahead is increased from 10 to 640.
 But this is not the case when the stride is greater than 40, where the
 maximum reduction in execution time is achieved in the middle value of
 the lookahead.
 
\end_layout

\begin_layout Standard
We must note that when the lookahead is small and the stride is large, there
 is a large portion of late helper thread L2 requests which can be explained
 intuitively as the helper thread skips too little in the prelude and prefetches
 too much in the stable state to keep running ahead of the main thread to
 fetch the data.
 In the other hand, when the lookahead is increased from 10 to 480 and the
 stride is large, the number of timely helper thread L2 requests diminishes,
 which implies the helper thread does too little prefetching work to provide
 tangible overall performance improvement.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_10_lookahead_0_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_10_lookahead_0_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(1a) Normalized Total Cycles (stride=10)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(1b) Helper Thread L2 Request Breakdown (stride=10)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_20_lookahead_0_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_20_lookahead_0_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(2a) Normalized Total Cycles (stride=20)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(2b) Helper Thread L2 Request Breakdown (stride=20)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_40_lookahead_0_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_40_lookahead_0_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(3a) Normalized Total Cycles (stride=40)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(3b) Helper Thread L2 Request Breakdown (stride=40)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_80_lookahead_0_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_80_lookahead_0_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(4a) Normalized Total Cycles (stride=80)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(4b) Helper Thread L2 Request Breakdown (stride=80)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_160_lookahead_0_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_160_lookahead_0_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(5a) Normalized Total Cycles (stride=160)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(5b) Helper Thread L2 Request Breakdown (stride=160)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_320_lookahead_0_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_320_lookahead_0_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(6a) Normalized Total Cycles (stride=320)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(6b) Helper Thread L2 Request Breakdown (stride=320)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_640_lookahead_0_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_0_640_lookahead_0_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(7a) Normalized Total Cycles (stride=480)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(7b) Helper Thread L2 Request Breakdown (stride=480)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Impact of Prefetching Lookahead on mst Helper Thread Performance
\begin_inset CommandInset label
LatexCommand label
name "fig:Impact-of-Lookahead-mst-ht"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Impact of Prefetching Stride
\end_layout

\begin_layout Standard
Fig.
\begin_inset CommandInset ref
LatexCommand ref
reference "fig:Impact-of-Stride-mst-ht"

\end_inset

 shows the normalized execution times in cycles and helper threaded L2 request
 breakdown for the mst helper threaded prefetching version when the stride
 is varied from 10 to 480.
 For clarity, execution times are normalized to the first case in the figure
 where the stride is 10.
 
\end_layout

\begin_layout Standard
We can see the relationship between the values of stride and the overall
 performance varies under different values of lookahead:
\end_layout

\begin_layout Enumerate
When the lookahead is less than 40, the execution time increases monotonically
 as the stride is increased from 10 to 640.
 It can be obviously interpreted as the harmful impacts of the increasing
 prohibitively large portion of late prefetches;
\end_layout

\begin_layout Enumerate
When the lookahead are 40 and 80, the greatest speedups are achieved when
 the stride is in the middle values of 80 and 320, respectively.
 It reflects the ongoing battle between the positive and negative performance
 gains from timely and late helper thread prefetches, respectively;
\end_layout

\begin_layout Enumerate
When the lookahead is greater than 160, the number of late helper thread
 prefetches diminishes to zero.
 This can be explained as the large value of lookahead in the prelude prevents
 the helper thread from lagging behind the main thread in the stable state.
 However, in this case, the execution time increases monotonically again
 as the value of lookahead becomes greater.
\end_layout

\begin_layout Standard
\align center
\begin_inset Float figure
wide true
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_10_5_stride_5_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_10_5_stride_5_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(1a) Normalized Total Cycles (lookahead=10)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(1b) Helper Thread L2 Request Breakdown (lookahead=10)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_20_5_stride_5_to_640_totalCycles_normalized.pdf
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_20_5_stride_5_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(2a) Normalized Total Cycles (lookahead=20)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(2b) Helper Thread L2 Request Breakdown (lookahead=20)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_40_5_stride_5_to_640_totalCycles_normalized.pdf
	display false
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_40_5_stride_5_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	display false
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(3a) Normalized Total Cycles (lookahead=40)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(3b) Helper Thread L2 Request Breakdown (lookahead=40)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_80_5_stride_5_to_640_totalCycles_normalized.pdf
	display false
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_80_5_stride_5_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	display false
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(4a) Normalized Total Cycles (lookahead=80)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(4b) Helper Thread L2 Request Breakdown (lookahead=80)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_160_5_stride_5_to_640_totalCycles_normalized.pdf
	display false
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_160_5_stride_5_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	display false
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(5a) Normalized Total Cycles (lookahead=160)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(5b) Helper Thread L2 Request Breakdown (lookahead=160)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_320_5_stride_5_to_640_totalCycles_normalized.pdf
	display false
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_320_5_stride_5_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	display false
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(6a) Normalized Total Cycles (lookahead=320)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(6b) Helper Thread L2 Request Breakdown (lookahead=320)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_640_5_stride_5_to_640_totalCycles_normalized.pdf
	display false
	scale 38
	clip

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/itecgo/Archimulator/experiment_plots/mst_2048_ht_640_5_stride_5_to_640_helperThreadL2CacheRequestBreakdowns.pdf
	display false
	scale 38
	BoundingBox 0bp 0bp 455bp 211bp
	clip

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(7a) Normalized Total Cycles (lookahead=480)
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size footnotesize
(7b) Helper Thread L2 Request Breakdown (lookahead=480)
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset VSpace defskip
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption

\begin_layout Plain Layout
Impact of Prefetching Stride on mst Helper Thread Performance
\begin_inset CommandInset label
LatexCommand label
name "fig:Impact-of-Stride-mst-ht"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Summary
\end_layout

\begin_layout Standard
From the above discussion on experimental results, we can conclude that,
 (1) too much late prefetches do great harm to the performance improvement
 of helper threaded prefetching; (2) the helper threaded prefetching parameters
 of lookahead and stride should and can be dynamically changed to balance
 the portions of timely and late prefetches using feedback directed mechanisms,
 thus leading to the maximal performance of helper threaded prefetching
 on CMPs; (3) there is little bad prefetches observed in our experiments
 on mst 
\begin_inset Quotes eld
\end_inset

2048 1
\begin_inset Quotes erd
\end_inset

, but it is expected to be prevalent in larger input set of the mst benchmark
 and other memory-intensive workloads.
\end_layout

\begin_layout Section
Related Work
\end_layout

\begin_layout Subsection
Prefetch Taxonomies
\end_layout

\begin_layout Standard
Even though helper threaded data prefetching mechanisms have been studied
 for a long time, LLC interference and taxonomy of helper thread LLC requests
 have not been studied before.
 Here we briefly describe previous work in the context of hardware prefetching.
 Our taxonomy of helper thread LLC requests is mostly similar to the work
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "Mehta2004"

\end_inset

, which presented a taxonomy of hardware prefetches based on the idea of
 shared cache pollution in the hardware based data prefetching for shared
 L2 CMP.
 A hardware structure called the 
\shape italic
Evict Table
\shape default
 (ET) is attached to the LLC to gauge the amount of shared cache pollution
 caused by hardware prefetching.
 The HTRVC in our proposal is similar to the evict table, however it is
 used for tracking helper thread request victims instead of hardware prefetch
 victims.
 Good, bad and ugly requests are identified based on cache replacement activitie
s involved by hardware prefetches.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Jerger2006"

\end_inset

 took the bandwidth consumption into account, and developed a multiprocessor
 prefetch traffic and miss taxonomy that builds on an existing uniprocessor
 prefetch taxonomy.
\end_layout

\begin_layout Subsection
Prefetch Aware Cache Content Management
\end_layout

\begin_layout Standard
The problem of cache content management in the presence of data prefetching,
 are studied in the previous works in the forms of software 
\begin_inset CommandInset citation
LatexCommand cite
key "Wang2002"

\end_inset

, hardware 
\begin_inset CommandInset citation
LatexCommand cite
key "Lai2001,Chen1995"

\end_inset

 and hybrid 
\begin_inset CommandInset citation
LatexCommand cite
key "Srinivasan2004"

\end_inset

.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Chen1991"

\end_inset

 proposed a prefetch buffer that can be attached to the L2 cache to filter
 the prefetched data from polluting the L2 cache, which is similar to but
 different from our proposed HTRVC cache structure whose sole function is
 for profiling helper thread L2 requests' victims.
 
\begin_inset CommandInset citation
LatexCommand cite
key "WuJMSE2011"

\end_inset

 characterized the performance of state-of-the-art LLC management policies
 in the presence and absence of hardware prefetching.
 Prefetch-Aware Cache Management (PACMan) was proposed to dynamically estimates
 and mitigates the degree of prefetch-induced cache interference by modifying
 the cache insertion and hit promotion policies to treat demand and prefetch
 requests differently.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Srinath2007"

\end_inset

 proposed a low-cost feedback directed mechanism for hardware prefetching.
 The mechanism can be applied to any hardware prefetchers such as sequential
 prefetchers, stream-based prefetchers, GHB based prefetchers and PC-based
 stride prefetchers.
\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
This paper first discusses the intra-application reuse distances in the
 helper threaded data prefetching on shared cache CMPs and their implications
 on helper thread performance.
 Based on this, we then proposes the intra-application interference aware
 taxonomy of helper thread LLC requests and its implementation details on
 a cycle-accurate CMP architectural simulator.
 Detailed experimental results of the memory intensive benchmark mst show
 that: (1) too much late prefetches do great harm to the performance improvement
 of helper threaded prefetching; and (2) the helper threading parameters
 of lookahead and stride should and can be dynamically changed to balance
 the portions of timely and late prefetches, thus leading to the maximal
 exploitation of helper threaded prefetching in improving the performance
 of irregular memory access workloads on shared cache CMPs.
 It can be part of our future work.
\end_layout

\begin_layout Section*
Acknowledgments
\end_layout

\begin_layout Standard
This work was supported by the National Natural Science Foundation of China
 under the contract No.
 61070029.
 
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "ref"
options "IEEEtran"

\end_inset


\end_layout

\end_body
\end_document
